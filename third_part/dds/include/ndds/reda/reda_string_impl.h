/* (c) Copyright 2003-2021, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)reda_string_impl.h    generated by: makeheader    Wed Mar  9 22:30:01 2022
 *
 *		built from:	string_impl.ifc
 */

#ifndef reda_string_impl_h
#define reda_string_impl_h


#ifdef __cplusplus
    extern "C" {
#endif


  #include "osapi/osapi_type.h"
  typedef RTI_INT8 utf8proc_int8_t;
  typedef RTI_UINT8 utf8proc_uint8_t;
  typedef RTI_INT16 utf8proc_int16_t;
  typedef RTI_UINT16 utf8proc_uint16_t;
  typedef RTI_INT32 utf8proc_int32_t;
  typedef RTI_UINT32 utf8proc_uint32_t;
  #if defined(RTI_64BIT)
    typedef RTI_INT64 utf8proc_ssize_t;
    typedef RTI_UINT64 utf8proc_size_t;
  #else
    typedef RTI_INT32 utf8proc_ssize_t;
    typedef RTI_UINT32 utf8proc_size_t;
  #endif
  typedef RTI_UINT8 utf8proc_bool;

extern REDADllExport 
utf8proc_ssize_t utf8proc_iterate(
        const utf8proc_uint8_t *str, 
        utf8proc_ssize_t strlen, 
        utf8proc_int32_t *codepoint_ref);


#define REDAString_getCharAndNext(str__, c__, encodingSize__, encodingKind__) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) *(str__); \
 \
    if ((encodingKind__) != REDA_CHARACTER_ENCODING_UTF8 || *ustr < 0x80) { \
        *(c__) = (RTI_INT32) *ustr; \
        *(encodingSize__) = 1; \
        ++(*(str__)); \
    } else { \
        utf8proc_ssize_t size__; \
        size__ = utf8proc_iterate( \
                ustr, \
                -1, \
                (utf8proc_int32_t *)(c__)); \
        if (size__ < 0 || size__ > RTI_INT32_MAX) { \
            /* Errors are handled by advancing one character */ \
            *(c__) = (RTI_INT32)*ustr; \
            *(encodingSize__) = 1; \
            ++(*(str__)); \
        } else { \
            *(encodingSize__) = (RTI_INT32) size__; \
            *(str__) += *(encodingSize__); \
        } \
    } \
}

#define REDAString_nextChar(str__, encodingKind__) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) *(str__); \
 \
    if ((encodingKind__) != REDA_CHARACTER_ENCODING_UTF8 || *ustr < 0x80) { \
        ++(*(str__)); \
    } else { \
        utf8proc_int32_t c__; \
        utf8proc_ssize_t size__; \
        size__ = utf8proc_iterate(ustr, -1, &c__); \
 \
        if (size__ < 0) { \
            /* Errors are handled by advancing one character */ \
            ++(*(str__)); \
        } else { \
            *(str__) += size__; \
        } \
    } \
}

#define REDAString_prevChar(str__, encodingKind__) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) *(str__); \
 \
    if ((encodingKind__) != REDA_CHARACTER_ENCODING_UTF8) { \
        --(*(str__)); \
    } else { \
        int i__; \
        utf8proc_ssize_t size__; \
        RTI_INT32 c__; \
 \
        for (i__=1; i__<=4; i__++) { \
            size__ = utf8proc_iterate(ustr - i__, -1, &c__); \
 \
            if (size__ > 0) { \
                *(str__) -= size__; \
                break; \
            } \
        } \
 \
        if (i__==5) { \
            /* Errors are handled by going back one character */ \
            --(*(str__)); \
        } \
    } \
}

#define REDAString_getChar(str__, c__, encodingSize__, encodingKind__) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) (str__); \
 \
    if ((encodingKind__) != REDA_CHARACTER_ENCODING_UTF8 || *ustr < 0x80) { \
        *(c__) = (RTI_INT32) *ustr; \
        *(encodingSize__) = 1; \
    } else { \
        utf8proc_ssize_t size__; \
        size__ = utf8proc_iterate( \
                ustr, \
                -1, \
                (utf8proc_int32_t *) (c__)); \
        if (size__ < 0 || size__ > RTI_INT32_MAX) { \
            /* Errors are handled by returning a single byte character */ \
            *(c__) = (RTI_INT32) *ustr; \
            *(encodingSize__) = 1; \
        } else { \
            *(encodingSize__) = (RTI_INT32) size__; \
        } \
    } \
}

#define REDAString_getCharAt( str__, c__,  encodingSize__, position__, encodingKind__) \
{ \
    const utf8proc_uint8_t *ustr = (const utf8proc_uint8_t *) (str__); \
 \
    if ((encodingKind__) != REDA_CHARACTER_ENCODING_UTF8) { \
        *(c__) = (RTI_INT32) ustr[(position__)]; \
        *(encodingSize__) = 1; \
    } else { \
        int i__; \
        utf8proc_ssize_t size__ = 0; \
        for (i__=0; i__<(position__); i__++) { \
            size__ = utf8proc_iterate( \
                    ustr, \
                    -1, \
                    (utf8proc_int32_t *) (c__)); \
 \
            if (size__ < 0 || size__ > RTI_INT32_MAX) { \
                break; \
            } \
 \
            ustr += size__; \
        } \
 \
        if (i__==(position__)) { \
            size__ = utf8proc_iterate( \
                    ustr, \
                    -1, \
                    (utf8proc_int32_t *) (c__)); \
        } \
 \
        if (size__ < 0 || size__ > RTI_INT32_MAX) { \
            /* Errors are handled by returning a single byte character */ \
            ustr = (const utf8proc_uint8_t *)(str__); \
            *(c__) = (RTI_INT32)ustr[(position__)]; \
            *(encodingSize__) = 1; \
        } else { \
            *(encodingSize__) = (RTI_INT32) size__; \
        } \
    } \
}


#define REDAChar_toLower(c__) \
    (((c__) < 0x80)? tolower((c__)): (RTI_INT32) utf8proc_tolower((c__)))


#define REDAChar_toUpper(c__) \
    (((c__) < 0x80) ? toupper((c__)) : (RTI_INT32) utf8proc_toupper((c__)))


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* reda_string_impl_h */
